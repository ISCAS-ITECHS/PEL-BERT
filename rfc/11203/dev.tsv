5391	MI	The Mode Index ( MI ) field ( 3 bits ) gives the mode of the following frame(s ) as per the table : +------------+--------------+------------+ | Mode Index | G.711.1 mode | Frame size | +------------+--------------+------------+ | 1 | R1 | 40 octets | | 2 | R2a | 50 octets | | 3 | R2b | 50 octets | | 4 | R3 | 60 octets | +------------+--------------+------------+ Table 3 : Modes in payload header All other values of MI are reserved for future use and MUST NOT be used .	240	0
5395	ID	The ID field identifies the query and is echoed in the response so they can be matched .	231	0
5395	QR	The QR bit indicates whether the header is for a query or a response .	210	0
5395	OpCode	Currently DNS OpCodes are assigned as follows : OpCode Name Reference 0 Query [ RFC1035 ] 1 IQuery ( Inverse Query , Obsolete ) [ RFC3425 ] 2 Status [ RFC1035 ] 3 available for assignment 4 Notify [ RFC1996 ] 5 Update [ RFC2136 ] 6-15 available for assignment New OpCode assignments require an IETF Standards Action as modified by [ RFC4020 ]	240	0
5413	Min	Min ( 4 bits ): the minor number of the SLAPP version	220	0
3549	Device Flags	32 bits IFF_UP Interface is administratively up . IFF_BROADCAST Valid broadcast address set . IFF_DEBUG Internal debugging flag . IFF_LOOPBACK Interface is a loopback interface . IFF_POINTOPOINT Interface is a point-to-point link . IFF_RUNNING Interface is operationally up . IFF_NOARP No ARP protocol needed for this interface . IFF_PROMISC Interface is in promiscuous mode . IFF_NOTRAILERS Avoid use of trailers . IFF_ALLMULTI Receive all multicast packets . IFF_MASTER Master of a load balancing bundle . IFF_SLAVE Slave of a load balancing bundle.IFF_PORTSEL Is able to select media type via ifmap . IFF_AUTOMEDIA Auto media selection active . IFF_DYNAMIC Interface was dynamically created . IFF_MULTICAST Supports multicast .	240	0
3550	V=2	2 bits This field identifies the version of RTP . The version defined by this specification is two ( 2 ). ( The value 1 is used by the first draft version of RTP and the value 0 is used by the protocol initially implemented in the  vat  audio tool .)	220	0
3550	P	1 bit If the padding bit is set , the packet contains one or more additional padding octets at the end which are not part of the payload . The last octet of the padding contains a count of how many padding octets should be ignored , including itself . Padding may be needed by some encryption algorithms with fixed block sizes or for carrying several RTP packets in a lower-layer protocol data unit .	210	0
3550	X	1 bit If the extension bit is set , the fixed header MUST be followed by exactly one header extension , with a format defined in Section 5.3.1.If the X bit in the RTP header is one , a variable-length header extension MUST be appended to the RTP header , following the CSRC list if present .	210	0
3550	CC	4 bits The CSRC count contains the number of CSRC identifiers that follow the fixed header .	230	0
3550	M	1 bit The interpretation of the marker is defined by a profile . It is intended to allow significant events such as frame boundaries to be marked in the packet stream . A profile MAY define additional marker bits or specify that there is no marker bit by changing the number of bits in the payload type field ( see Section 5.3 ). Additional information that is required for a particular payload format , such as a video encoding , SHOULD be carried in the payload section of the packet . This might be in a header that is always present at the start of the payload section , or might be indicated by a reserved value in the data pattern .	210	0
3550	PT	7 bits This field identifies the format of the RTP payload and determines its interpretation by the application . A profile MAY specify a default static mapping of payload type codes to payload formats . Additional payload type codes MAY be defined dynamically through non-RTP means ( see Section 3 ). A set of default mappings for audio and video is specified in the companion RFC 3551 [ 1 ]. An RTP source MAY change the payload type during a session , but this field SHOULD NOT be used for multiplexing separate media streams ( see Section 5.2 ). For example , in a teleconference composed of audio and video media encoded separately , each medium SHOULD be carried in a separate RTP session with its own destination transport address . Separate audio and video streams SHOULD NOT be carried in a single RTP session and demultiplexed based on the payload type or SSRC fields . Interleaving packets with different RTP media types but using the same SSRC would introduce several problems :	231	0
3588	End-to-End Identifier	The End-to-End Identifier is an unsigned 32-bit integer field ( in network byte order ) and is used to detect duplicate messages . Upon reboot implementations MAY set the high order 12 bits to contain the low order 12 bits of current time , and the low order 20 bits to a random value . Senders of request messages MUST insert a unique identifier on each message . The identifier MUST remain locally unique for a period of at least 4 minutes , even across reboots . The originator of an Answer message MUST ensure that the End-to-End Identifier field contains the same value that was found in the corresponding request . The End-to-End Identifier MUST NOT be modified by Diameter agents of any kind . The combination of the Origin-Host ( see Section 6.3 ) and this field is used to detect duplicates . Duplicate requests SHOULD cause the same answer to be transmitted ( modulo the hop-by-hop Identifier field and any routing AVPs that may be present ), and MUST NOT affect any state that was set when the original request was processed . Duplicate answer messages that are to be locally consumed ( see Section 6.2 ) SHOULD be silently discarded .	231	0
3984	V=2	1 bit Set for the very last packet of the access unit indicated by the RTP timestamp , in line with the normal use of the M bit in video formats , to allow an efficient playout buffer handling . For aggregation packets ( STAP and MTAP ), the marker bit in the RTP header MUST be set to the value that the marker bit of the last NAL unit of the aggregation packet would have been if it were transported in its own RTP packet . Decoders MAY use this bit as an early indication of the last packet of an access unit , but MUST NOT rely on this property . Informative note : Only one M bit is associated with an aggregation packet carrying multiple NAL units . Thus , if a gateway has re-packetized an aggregation packet into several packets , it cannot reliably set the M bit of those packets .	210	0
3984	PT	7 bits The assignment of an RTP payload type for this new packet format is outside the scope of this document and will not be specified here . The assignment of a payload type has to be performed either through the profile used or in a dynamic way .	231	0
4103	M	The M-bit MUST be included . The first packet in a session , and the first packet after an idle period , SHOULD be distinguished by setting the marker bit in the RTP data header to one . The marker bit in all other packets MUST be set to zero . The reception of the marker bit MAY be used for refined methods for detection of loss .	230	0
4103	T140 PT	The assignment of an RTP payload type is specific to the RTP profile under which the payload format is used . For profiles that use dynamic payload type number assignment , this payload format can be identified by the MIME type  text/t140  ( see Section 10 ). If redundancy is used per RFC 2198 , another payload type number needs to be provided for the redundancy format . The MIME type for identifying RFC 2198 is available in RFC 4102 [ 9 ].	231	0
4165	Version	The version field contains the version of M2PA . The supported versions are : Value ( decimal ) Version --------- ------- 1 Release 1.0 of M2PA protocol	231	0
4302	Security Parameters Index	The SPI is an arbitrary 32-bit value that is used by a receiver to identify the SA to which an incoming packet is bound . For a unicast SA , the SPI can be used by itself to specify an SA , or it may be used in conjunction with the IPsec protocol type ( in this case AH ). Because for unicast SAs the SPI value is generated by the receiver , whether the value is sufficient to identify an SA by itself or whether it must be used in conjunction with the IPsec protocol value is a local matter . The SPI field is mandatory , and this mechanism for mapping inbound traffic to unicast SAs described above MUST be supported by all AH implementations . If an IPsec implementation supports multicast , then it MUST support multicast SAs using the algorithm below for mapping inbound IPsec datagrams to SAs . Implementations that support only unicast traffic need not implement this de-multiplexing algorithm . In many secure multicast architectures , e.g ., [ RFC3740 ], a central Group Controller/Key Server unilaterally assigns the group security association's SPI . This SPI assignment is not negotiated or coordinated with the key management ( e.g ., IKE ) subsystems that reside in the individual end systems that comprise the group . Consequently , it is possible that a group security association and a unicast security association can simultaneously use the same SPI . A multicast-capable IPsec implementation MUST correctly de-multiplex inbound traffic even in the context of SPI collisions . Each entry in the Security Association Database ( SAD ) [ Ken-Arch ] must indicate whether the SA lookup makes use of the destination , or destination and source , IP addresses , in addition to the SPI . For multicast SAs , the protocol field is not employed for SA lookups . For each inbound , IPsec-protected packet , an implementation must conduct its search of the SAD such that it finds the entry that matches the  longest  SA identifier . In this context , if two or more SAD entries match based on the SPI value , then the entry that also matches based on destination , or destination and source , address comparison ( as indicated in the SAD entry ) is the  longest  match . This implies a logical ordering of the SAD search as follows : 1 . Search the SAD for a match on { SPI , destination address , source address }. If an SAD entry matches , then process the inbound AH packet with that matching SAD entry . Otherwise , proceed to step 2 . 2 . Search the SAD for a match on { SPI , destination address }. If an SAD entry matches , then process the inbound AH packet with that matching SAD entry . Otherwise , proceed to step 3 . 3 . Search the SAD for a match on only { SPI } if the receiver has chosen to maintain a single SPI space for AH and ESP , or on { SPI , protocol } otherwise . If an SAD entry matches , then process the inbound AH packet with that matching SAD entry . Otherwise , discard the packet and log an auditable event . In practice , an implementation MAY choose any method to accelerate this search , although its externally visible behavior MUST be functionally equivalent to having searched the SAD in the above order . For example , a software-based implementation could index into a hash table by the SPI . The SAD entries in each hash table bucket's linked list are kept sorted to have those SAD entries with the longest SA identifiers first in that linked list . Those SAD entries having the shortest SA identifiers are sorted so that they are the last entries in the linked list . A hardware-based implementation may be able to effect the longest match search intrinsically , using commonly available Ternary Content-Addressable Memory ( TCAM ) features . The indication of whether source and destination address matching is required to map inbound IPsec traffic to SAs MUST be set either as a side effect of manual SA configuration or via negotiation using an SA management protocol , e.g ., IKE or Group Domain of Interpretation ( GDOI ) [ RFC3547 ]. Typically , Source-Specific Multicast ( SSM ) [ HC03 ] groups use a 3-tuple SA identifier composed of an SPI , a destination multicast address , and source address . An Any-Source Multicast group SA requires only an SPI and a destination multicast address as an identifier . The set of SPI values in the range 1 through 255 is reserved by the Internet Assigned Numbers Authority ( IANA ) for future use; a reserved SPI value will not normally be assigned by IANA unless the use of the assigned SPI value is specified in an RFC . The SPI value of zero ( 0 ) is reserved for local , implementation-specific use and MUST NOT be sent on the wire . ( For example , a key management implementation might use the zero SPI value to mean  No Security Association Exists  during the period when the IPsec implementation has requested that its key management entity establish a new SA , but the SA has not yet been established .)	231	0
4302	Integrity Check Value-ICV (variable)	This is a variable-length field that contains the Integrity Check Value ( ICV ) for this packet . The field must be an integral multiple of 32 bits ( IPv4 or IPv6 ) in length . The details of ICV processing are described in Section 3.3.3 ,  Integrity Check Value Calculation , and Section 3.4.4 ,  Integrity Check Value Verification . This field may include explicit padding , if required to ensure that the length of the AH header is an integral multiple of 32 bits ( IPv4 ) or 64 bits ( IPv6 ). All implementations MUST support such padding and MUST insert only enough padding to satisfy the IPv4/IPv6 alignment requirements . Details of how to compute the required padding length are provided below in Section 3.3.3.2 ,  Padding . The integrity algorithm specification MUST specify the length of the ICV and the comparison rules and processing steps for validation .	301	0
6597	M-bit(marker bit)	The RTP header marker bit ( M ) is used to demarcate | | | KLVunits . Senders MUST set the marker bit to ' 1 ' for | | | any RTP packet that contains the final byte of a | | | KLVunit . For all other packets , senders MUST set the | | | RTP header marker bit to ' 0 '. This allows receivers | | | to pass a KLVunit for parsing/decoding immediately | | | upon receipt of the last RTP packet comprising the | | | KLVunit . Without this , a receiver would need to wait | | | for the next RTP packet with a different timestamp to | | | arrive , thus signaling the end of one KLVunit and the | | | start of another .	210	0
6621	Option Type	Option Type  = 00001000 . The highest order three bits are 000 because this specification requires that routers not recognizing this option type skip over this option and continue processing the header and that the option must not change en route [ RFC2460 ].	231	0
6621	Opt. Data Len	Opt . Data Len  = Length of option content ( i.e ., 1 + (< IdType > ? (< IdLen > + 1 ): 0 ) + Length(DPD ID )).	100	0
6621	H(H-bit)	H-bit  = a hash indicator bit value identifying DPD marking type . 0 == sequence-based approach with optional TaggerId and a tuple-based sequence number . 1 == indicates a hash assist value ( HAV ) field follows to aid in avoiding hash-based DPD collisions .	210	0
6621	TidTy	a 3-bit field indicating the presence and type of the optional TaggerId field .	231	0
6621	TidLen	a 4-bit field indicating the length ( in octets ) of the following TaggerId field .	100	0
6621	TaggerId (optional)	a field , is used to differentiate multiple ingressing border gateways that may commonly apply the SMF_DPD option header to packets from a particular source . Table 1 lists the TaggerId types used in this document : +---------+---------------------------------------------------------+ | Name | Purpose | +---------+---------------------------------------------------------+ | NULL | Indicates no TaggerId field is present .  TidLen  MUST | | | also be set to ZERO . | | DEFAULT | A TaggerId of non-specific context is present .  TidLen | | | + 1  defines the length of the TaggerId field in bytes . | | IPv4 | A TaggerId representing an IPv4 address is present . The | | |  TidLen  MUST be set to 3 . | | IPv6 | A TaggerId representing an IPv6 address is present . The | | |  TidLen  MUST be set to 15 . | +---------+---------------------------------------------------------+ Table 1 : TaggerId TypesThis format allows a quick check of the  TidTy  field to determine if a TaggerId field is present . If  TidTy  is NULL , then the length of the DPD packet < Identifier > field corresponds to (< Opt . Data Len > - 1 ). If the < TidTy > is non-NULL , then the length of the TaggerId field is equal to (< TidLen > - 1 ), and the remainder of the option data comprises the DPD packet < Identifier > field . When the TaggerId field is present , the < Identifier > field can be considered a unique packet identifier in the context of the < TaggerId:srcAddr:dstAddr > tuple . When the TaggerId field is not present , then it is assumed that the source applied the SMF_DPD option and the < Identifier > can be considered unique in the context of the IPv6 packet header < srcAddr:dstAddr > tuple . IPv6 I-DPD operation details are in	230	1
6621	Hash Assist Value (HAV)	The SMF_DPD option should be applied with an HAV to produce a unique hash digest for packets within the context of the IPv6 packet header < srcAddr >. The size of the HAV field is implied by  Opt . Data Len . The appropriate size of the field depends upon the collision properties of the specific hash algorithm used .	231	1
6716	config	The top five bits of the TOC byte , labeled  config , encode one of 32 possible configurations of operating mode , audio bandwidth , and frame size . As described , the LP ( SILK ) layer and MDCT ( CELT ) layer can be combined in three possible operating modes:The 32 possible configurations each identify which one of these operating modes the packet uses , as well as the audio bandwidth and the frame size . Table 2 lists the parameters for each configuration .	240	0
6716	s	One additional bit , labeled  s , signals mono vs . stereo , with 0 indicating mono and 1 indicating stereo .	210	0
6716	c	The remaining two bits of the TOC byte , labeled  c , code the number of frames per packet ( codes 0 to 3 ) as follows : o 0 : 1 frame in the packet o 1 : 2 frames in the packet , each with equal compressed size o 2 : 2 frames in the packet , with different compressed sizes o 3 : an arbitrary number of frames in the packet This document refers to a packet as a code 0 packet , code 1 packet , etc ., based on the value of  c .	240	0
6733	Version	This Version field MUST be set to 1 to indicate Diameter Version 1 .	220	0
6733	Message Length	The Message Length field is three octets and indicates the length of the Diameter message including the header fields and the padded AVPs . Thus , the Message Length field is always a multiple of 4 .	100	0
6733	Command Flags	The Command Flags field is eight bits . The following bits are assigned :	231	0
6733	Command Code	The Command Code field is three octets and is used in order to communicate the command associated with the message . The 24-bit address space is managed by IANA ( see Section 3.1 ). Command Code values 16,777,214 and 16,777,215 ( hexadecimal values FFFFFE - FFFFFF ) are reserved for experimental use ( see Section 11.2 ).	231	0
6733	Application-ID	Application-ID is four octets and is used to identify for which application the message is applicable . The application can be an authentication application , an accounting application , or a vendor-specific application . The value of the Application-ID field in the header MUST be the same as any relevant Application-Id AVPs contained in the message .	231	0
6733	Hop-by-Hop Identifier	The Hop-by-Hop Identifier is an unsigned 32-bit integer field ( in network byte order ) that aids in matching requests and replies . The sender MUST ensure that the Hop-by-Hop Identifier in a request is unique on a given connection at any given time , and it MAY attempt to ensure that the number is unique across reboots . The sender of an answer message MUST ensure that the Hop-by-Hop Identifier field contains the same value that was found in the corresponding request . The Hop-by-Hop Identifier is normally a monotonically increasing number , whose start value was randomly generated . An answer message that is received with an unknown Hop-by-Hop Identifier MUST be discarded .	231	0
6733	End-to-End Identifier	The End-to-End Identifier is an unsigned 32-bit integer field ( in network byte order ) that is used to detect duplicate messages . Upon reboot , implementations MAY set the high order 12 bits to contain the low order 12 bits of current time , and the low order 20 bits to a random value . Senders of request messages MUST insert a unique identifier on each message . The identifier MUST remain locally unique for a period of at least 4 minutes , even across reboots . The originator of an answer message MUST ensure that the End-to-End Identifier field contains the same value that was found in the corresponding request . The End-to-End Identifier MUST NOT be modified by Diameter agents of any kind . The combination of the Origin-Host AVP ( Section 6.3 ) and this field is used to detect duplicates . Duplicate requests SHOULD cause the same answer to be transmitted ( modulo the Hop-by-Hop Identifier field and any routing AVPs that may be present ), and they MUST NOT affect any state that was set when the original request was processed . Duplicate answer messages that are to be locally consumed ( see Section 6.2 ) SHOULD be silently discarded .	231	0
6733	AVP Code	The AVP Code , combined with the Vendor-Id field , identifies the attribute uniquely . AVP numbers 1 through 255 are reserved for reuse of RADIUS attributes , without setting the Vendor-Id field . AVP numbers 256 and above are used for Diameter , which are allocated by IANA ( see Section 11.1.1 ).	231	0
6733	AVP Flags	The AVP Flags field informs the receiver how each attribute must be handled . New Diameter applications SHOULD NOT define additional AVP Flag bits . However , note that new Diameter applications MAY define additional bits within the AVP header , and an unrecognized bit SHOULD be considered an error . The sender of the AVP MUST set ' R ' ( reserved ) bits to 0 and the receiver SHOULD ignore all ' R ' ( reserved ) bits . The ' P ' bit has been reserved for future usage of end-to-end security . At the time of writing , there are no end-to-end security mechanisms specified; therefore , the ' P ' bit SHOULD be set to 0 . The ' M ' bit , known as the Mandatory bit , indicates whether the receiver of the AVP MUST parse and understand the semantics of the AVP including its content . The receiving entity MUST return an appropriate error message if it receives an AVP that has the M-bitset but does not understand it . An exception applies when the AVP is embedded within a Grouped AVP . See Section 4.4 for details . Diameter relay and redirect agents MUST NOT reject messages with unrecognized AVPs . The ' M ' bit MUST be set according to the rules defined in the application specification that introduces or reuses this AVP . Within a given application , the M-bit setting for an AVP is defined either for all command types or for each command type . AVPs with the ' M ' bit cleared are informational only; a receiver that receives a message with such an AVP that is not supported , or whose value is not supported , MAY simply ignore the AVP . The ' V ' bit , known as the Vendor-Specific bit , indicates whether the optional Vendor-ID field is present in the AVP header . When set , the AVP Code belongs to the specific vendor code address space .	231	0
6733	AVP Length	The AVP Length field is three octets , and indicates the number of octets in this AVP including the AVP Code field , AVP Length field , AVP Flags field , Vendor-ID field ( if present ), and the AVP Data field . If a message is received with an invalid attribute length , the message MUST be rejected . The AVP header contains one optional field . This field is only present if the respective bit-flag is enabled .	100	0
6733	Vendor-ID	The Vendor-ID field is present if the ' V ' bit is set in the AVP Flags field . The optional four-octet Vendor-ID field contains the IANA-assigned  SMI Network Management Private Enterprise Codes  [ ENTERPRISE ] value , encoded in network byte order . Any vendors or standardization organizations that are also treated like vendors in the IANA-managed  SMI Network Management Private Enterprise Codes  space wishing to implement a vendor-specific Diameter AVP MUST use their own Vendor-ID along with their privately managed AVP address space , guaranteeing that they will not collide with any other vendor's vendor-specific AVP(s ) or with future IETF AVPs.A Vendor-ID value of zero ( 0 ) corresponds to the IETF-adopted AVP values , as managed by IANA . Since the absence of the Vendor-ID field implies that the AVP in question is not vendor specific , implementations MUST NOT use the value of zero ( 0 ) for the Vendor-ID field .	231	0
6733	Data	The Data field is zero or more octets and contains information specific to the Attribute . The format and length of the Data field is determined by the AVP Code and AVP Length fields . The format of the Data field MUST be one of the following base data types or a data type derived from the base data types . In the event that a new Basic AVP Data Format is needed , a new version of this RFC MUST be created .	400	1
5415	Frag Offset	A 13-bit field that indicates where in the payload this fragment belongs during re-assembly . This field is valid when the ' F ' bit is set to 1 . The fragment offset is measured in units of 8 octets ( 64 bits ). The first fragment has offset zero . Note that the CAPWAP protocol does not allow for overlapping fragments .	231	0
5415	Rsvd	The 3-bit field is reserved for future use . All implementations complying with this protocol MUST set to zero any bits that are reserved in the version of the protocol supported by that implementation . Receivers MUST ignore all bits not defined for the version of the protocol they support .	500	0
5433	Length	The Length field is two octets and indicates the length , in octets , of the EAP packet including the Code , Identifier , Length , and Data fields . Octets outside the range of the Length field should be treated as Data Link Layer padding and MUST be ignored upon reception . A message with the Length field set to a value larger than the number of received octets MUST be silently discarded .	100	0
5433	Type	The Type field is one octet . This field indicates the Type of Request or Response . A single Type MUST be specified for each EAP Request or Response . An initial specification of Types follows in Section 5 of this document . The Type field of a Response MUST either match that of the Request , or correspond to a legacy or Expanded Nak ( see Section 5.3 ) indicating that a Request Type is unacceptable to the peer . A peer MUST NOT send a Nak ( legacy or expanded ) in response to a Request , after an initial non-Nak Response has been sent . An EAP server receiving a Response not meeting these requirements MUST silently discard it .	231	0
5433	OP-Code	The OP-Code field is one of 6 values : o 0x00 : Reserved o 0x01 : GPSK-1 o 0x02 : GPSK-2 o 0x03 : GPSK-3 o 0x04 : GPSK-4 o 0x05 : GPSK-Fail o 0x06 : GPSK-Protected-Fail All other values of this OP-Code field are available via IANA registration .	240	0
5433	Payload	Payload formatting is based on the protocol exchange description	400	1
5440	Ver	( Version - 3 bits ): PCEP version number . Current version is version 1 .	220	0
